const got = require("got");
// const fs = require("fs");
const FormData = require("form-data");
const PassThrough = require("stream").PassThrough;
const config = require("./../../config/index");
const Hooker = require("./../../hooker");
const crowdin = require("@crowdin/crowdin-api-client");

// initialization of crowdin client
const apis = new crowdin.default({
  // FIXME: use access token of neocoin(organization owner)
  token:
    "8e0e7e8c4de31297257d78f60c597dbc8bf183f2113f8108c82bdce89e6b3e45f93bcc993a94071d",
  // organization: "organizationName", // optional
});

const ORIGIN = "https://crowdin.com";
const APIS = {
  projects() {
    return `${ORIGIN}/api/v2/projects`;
  },
  listFile(projectId) {
    return `${ORIGIN}/api/v2/projects/${projectId}/files`;
  },
  projectInfo(projectId) {
    return `${ORIGIN}/api/v2/projects/${projectId}`;
  },
  downloadFile(projectId, fileId) {
    return `${ORIGIN}/api/v2/projects/${projectId}/files/${fileId}/download`;
  },
  listKeys(projectId) {
    return `${ORIGIN}/api/v2/projects/${projectId}/strings`;
  },
  fileTranslateStatus(projectId, fileId) {
    return `${ORIGIN}/api/v2/projects/${projectId}/files/${fileId}/languages/progress`;
  },
};

class Request {
  constructor() {
    this._headers = {
      Authorization: `Bearer ${config.authToken}`,
      "user-agent":
        "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36",
    };
  }

  get(url, parameter = {}) {
    return got(url, {
      headers: this._headers,
      isStream: false,
      searchParams: parameter,
    });
  }

  post(url, { form, query }) {
    return got(url, {
      headers: this._headers,
      method: "post",
      searchParams: query,
      form,
    });
  }

  getFormData(form = {}) {
    const formData = new FormData();
    Reflect.ownKeys(form).forEach((a) => {
      formData.append(a, form[a]);
    });
    return formData;
  }

  getStream(url, parameter = {}) {
    return got(url, {
      headers: this._headers,
      searchParams: parameter,
      isStream: true,
    });
  }
}

class Crowdin {
  constructor({ projectId }) {
    this.projectId = projectId;
    this.apis = apis;
    this._request = new Request();
  }

  get request() {
    return this._request;
  }

  getProjects() {
    return this.request
      .get(APIS.projects(), { limit: 500 })
      .then(({ body }) => {
        return JSON.parse(body);
      });
  }

  getProjectDetail() {
    const languages = this.getProject().then((x) =>
      x.data.targetLanguages.map((lang) => ({
        id: lang.id,
        name: lang.name,
        code: lang.locale,
        can_translate: 1,
        can_approve: 1,
      }))
    );
    const files = this.apis.sourceFilesApi
      .withFetchAll()
      .listProjectFiles(this.projectId)
      .then((x) =>
        x.data.map((file) => ({
          node_type: "file",
          id: file.data.id,
          name: file.data.name,
          created: file.data.createdAt,
          last_updated: file.data.updatedAt,
          last_accessed: file.data.updatedAt,
          last_revision: file.data.revisionId,
        }))
      );
    const details = this.getProject()
      .then((x) =>
        this.apis.languagesApi.getLanguage(x.data.sourceLanguageId).then(
          (y) => (
            (x.data.source_language = {
              name: y.data.name,
              code: y.data.code,
            }),
            x.data
          )
        )
      )
      .then((x) => ({
        source_language: x.source_language,
        name: x.name,
        identifier: x.identifier,
        created: x.createdAt,
        description: x.description,
        join_policy: x.visibility,
        last_build: x.lastActivity,
        last_activity: x.lastActivity,
        participants_count: 1,
        logo_url: x.logo,
        total_strings_count: 1,
        total_words_count: 1,
        duplicate_string_count: x.translateDuplicates,
        duplicate_words_count: 0,
        invite_url: {
          translator: "https:xxx",
          proofreader: "https:xxx.com",
        },
      }));
    return Promise.all([languages, files, details]).then(
      ([langRes, fileRes, detailRes]) => ({
        languages: langRes,
        files: fileRes,
        details: detailRes,
      })
    );
  }

  getProjectInfo(projectId) {
    return this.request.get(APIS.projectInfo(projectId)).then(({ body }) => {
      return JSON.parse(body);
    });
  }

  getProject() {
    return this.apis.projectsGroupsApi.getProject(this.projectId);
  }

  getProjectFiles(fileName) {
    return this.request
      .get(APIS.listFile(this.projectId), { filter: fileName })
      .then(({ body }) => {
        return JSON.parse(body);
      });
  }

  addFileByBuffer(fileName, fileStream, ops, other = {}) {
    return apis.uploadStorageApi
      .addStorage(`${fileName}_v1`, fileStream)
      .then((x) =>
        apis.sourceFilesApi.createFile(this.projectId, {
          name: fileName,
          storageId: x.data.id,
        })
      )
      .then((x) => x.data);
  }

  updateFileByBuffer(fileName, fileStream, ops, other = {}) {
    return apis.sourceFilesApi
      .listProjectFiles(this.projectId, { filter: fileName })
      .then((files) => {
        if (!files.data || files.data.length === 0) {
          return Promise.reject(
            "can not find the file from project ",
            this.projectId
          );
        }
        const x = files.data[0];
        return apis.uploadStorageApi
          .addStorage(`${fileName}_v${x.data.revisionId + 1}`, fileStream)
          .then((y) => Object.assign(y.data, { fileId: x.data.id }));
      })
      .then((x) =>
        apis.sourceFilesApi.updateOrRestoreFile(this.projectId, x.fileId, {
          storageId: x.id,
          updateOption: "keep_translations_and_approvals",
        })
      )
      .then((x) => x.data)
      .catch((x) => console.log(x));
  }

  uploadTransitionByBuffer(fileName, fileStream, language, other = {}) {
    return apis.uploadStorageApi
      .addStorage(`${fileName}_${+new Date()}`, fileStream)
      .then((x) => {
        return apis.sourceFilesApi
          .listProjectFiles(this.projectId, { filter: fileName })
          .then((files) => {
            const fileInfo = files.data[0].data;
            return apis.translationsApi.uploadTranslation(
              this.projectId,
              language,
              {
                storageId: x.data.id,
                fileId: fileInfo.id,
                importEqSuggestions: true,
                ...other,
              }
            );
          });
      });
  }

  built() {
    return this.apis.translationsApi
      .buildProject(this.projectId, {
        // TODO: whether export only translated strings or only translated files
        // skipUntranslatedStrings: true,
        // skipUntranslatedFiles: true,
        exportApprovedOnly: true,
      })
      .then((x) => x.data);
  }

  buildInProgress(buildId = null, status = "") {
    if (!buildId) {
      return this.built().then((x) => this.buildInProgress(x.id, x.status));
    }

    if (status === "created" || status === "inProgress") {
      return this.apis.translationsApi
        .checkBuildStatus(this.projectId, buildId)
        .then((x) =>
          Hooker.emit("built-progress", { progress: x.data.progress }).then(
            () =>
              new Promise((res, rej) => setTimeout(() => res(x), 1000)).then(
                (y) => this.buildInProgress(buildId, y.data.status)
              )
          )
        );
    }

    return this.apis.translationsApi
      .checkBuildStatus(this.projectId, buildId)
      .then((x) => x.data);
  }

  getDownloadStream(buildId) {
    return apis.translationsApi
      .downloadTranslations(this.projectId, buildId)
      .then((x) => got.stream(x.data.url))
      .catch((e) => console.log(e));
  }

  downloadFile({ projectId, fileId }) {
    return this.request
      .get(APIS.downloadFile(projectId, fileId))
      .then(({ body }) => {
        return JSON.parse(body);
      })
      .then(({ data }) => {
        return got(data.url, {
          headers: {
            "user-agent":
              "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.132 Safari/537.36",
          },
          isStream: true,
        });
      });
  }

  getFileContent({ projectId, fileId }) {
    return new Promise((resolve, reject) => {
      let t = new PassThrough(),
        d = null;
      t.on("data", (chunck) => {
        if (!d) {
          d = chunck;
        } else {
          d = Buffer.concat([d, chunck]);
        }
      });
      t.on("end", () => {
        resolve(d.toString());
      });
      t.on("error", () => {
        reject();
      });
      this.downloadFile({ projectId, fileId }).then((stream) => stream.pipe(t));
    });
  }

  getKeysList({ projectId }) {
    return this.request
      .get(APIS.listKeys(projectId), { limit: 500 })
      .then(({ body }) => {
        return JSON.parse(body);
      });
  }

  getFileTranslateStatus(projectId, fileId) {
    return this.request
      .get(APIS.fileTranslateStatus(projectId, fileId))
      .then(({ body }) => {
        return JSON.parse(body);
      });
  }
}

module.exports = Crowdin;
