const fs = require("fs");
const v1 = require("./v1");
const v2 = require("./v2");
const { File } = require("ada-util");
const config = require("./../../config");
const Hooker = require("./../../hooker");
const util = require("./../index");

class Crowdin {
  constructor({ projectId, project, key }) {
    project = project || `fed-crowdin-${projectId}`;
    this._projectName = project;
    this._projectId = projectId;
    this._v1 = new v1({ project, key });
    this._v2 = new v2({ projectId });
    this.upgraded = !!projectId;
  }

  get projectId() {
    return this._projectId;
  }

  get projectName() {
    return this._projectName;
  }

  getProjectId() {
    let _cache_project_path = config._cache_pro_path;
    if (new File(_cache_project_path).exist) {
      try {
        return Promise.resolve(require(_cache_project_path).id);
      } catch (e) {}
    }

    return this._v2.getProjects().then((list) => {
      let pro = list.data.find((b) => {
        return b.data.id === this.projectId;
      });
      if (pro) {
        return new File(_cache_project_path)
          .write(JSON.stringify(pro.data))
          .then(() => {
            return pro.data.id;
          });
      } else {
        return Promise.reject("can not find the project,check project name");
      }
    });
  }

  getFileId(fileName) {
    if (!this.upgraded) {
      return this.getProjectDetail().then(({ files }) => {
        let target = files.find((a) => a.name === fileName);
        return target ? target.id : null;
      });
    }

    return this.getProjectFiles(fileName).then(({ data: files }) => {
      let target = files.find((a) => a.data.name === fileName);
      return target && target.data ? target.data.id : null;
    });
  }

  getProjectFiles(fileName = "") {
    return this._v2.getProjectFiles(fileName);
  }

  getProjectDetail() {
    return this.upgraded
      ? this._v2.getProjectDetail()
      : this._v1.getProjectDetail();
  }

  getFileContent(fileId, fileName) {
    return Hooker.emit("getkey-start", { fileId, fileName })
      .then(() => {
        return this.getProjectId();
      })
      .then((projectId) => {
        return this._v2.getFileContent({ projectId, fileId });
      })
      .then((content) => {
        return Hooker.emit("getkey-end", { fileId, fileName, content }).then(
          () => content
        );
      })
      .catch((e) => {
        return Hooker.emit("getkey-end", { fileId, fileName, error: e }).then(
          () => null
        );
      });
  }

  addFileByBuffer(fileName, fileBuffer, ops, other) {
    return Hooker.emit("uploadkey-start", { fileName })
      .then(() => {
        const api = this.upgraded ? this._v2 : this._v1;
        return api.addFileByBuffer(fileName, fileBuffer, ops, other);
      })
      .then(() => {
        return Hooker.emit("uploadkey-end", { fileName });
      })
      .catch((e) => {
        return Hooker.emit("uploadkey-end", { fileName, error: e });
      });
  }

  updateFileByBuffer(fileName, fileBuffer, ops, other) {
    return Hooker.emit("uploadkey-start", { fileName })
      .then(() => {
        const api = this.upgraded ? this._v2 : this._v1;
        return api.updateFileByBuffer(fileName, fileBuffer, ops, other);
      })
      .then(() => {
        return Hooker.emit("uploadkey-end", { fileName });
      })
      .catch((e) => {
        return Hooker.emit("uploadkey-end", { fileName, error: e });
      });
  }

  addOrUpdateFile({ fileName, data = [], ops, other }) {
    if (Array.isArray(data)) {
      if (data.length > 0) {
        let r = {};
        data.forEach((a) => {
          r[util.getKeyCode(a)] = a;
        });
        return this.getFileId(fileName).then((id) => {
          const action = id ? this.updateFileByBuffer : this.addFileByBuffer;
          return action.call(
            this,
            fileName,
            Buffer.from(JSON.stringify(r)),
            ops,
            other
          );
        });
      }
      return Promise.resolve();
    } else {
      return Promise.reject("array[keys] needed");
    }
  }

  uploadTranslation({ fileName, data = {}, language, langCode = "", other }) {
    if (language) {
      language = util.getCrowdinLangCode(language);
    } else {
      language = langCode;
    }
    if (language) {
      if (typeof data === "object" && !Array.isArray(data)) {
        let r = {},
          has = false;
        Reflect.ownKeys(data).forEach((key) => {
          has = true;
          r[util.getKeyCode(key)] = data[key];
        });
        if (has) {
          let fileBuffer = Buffer.from(JSON.stringify(r));
          return Hooker.emit("uploadtranslate-start", { fileName, language })
            .then(() => {
              const api = this.upgraded ? this._v2 : this._v1;
              return api.uploadTransitionByBuffer(
                fileName,
                fileBuffer,
                language,
                other
              );
            })
            .then(() => {
              return Hooker.emit("uploadtranslate-end", { fileName, language });
            })
            .catch((e) => {
              return Hooker.emit("uploadtranslate-end", {
                fileName,
                language,
                error: e,
              });
            });
        }
        return Promise.resolve();
      } else {
        return Promise.reject("object{key:translate} needed");
      }
    } else {
      return Promise.reject("language can not found");
    }
  }

  downloadLanguagePack(toLocalPath) {
    return Hooker.emit("build-start")
      .then(() => {
        return this.upgraded ? this._v2.buildInProgress() : this._v1.built();
      })
      .then((a) => {
        return Hooker.emit("build-end", a).then((x) => a);
      })
      .catch((e) => {
        return Hooker.emit("build-end", { error: e });
      })
      .then((x) =>
        this.upgraded
          ? this._v2.getDownloadStream(x.id)
          : Promise.resolve(this._v1.getDownloadStream())
      )
      .then((stream) => {
        return new Promise((resolve, reject) => {
          return stream
            .on("response", () => {
              Hooker.emit("download-start");
            })
            .on("downloadProgress", (a) => {
              Hooker.emit("download-progress", a);
            })
            .pipe(fs.createWriteStream(toLocalPath))
            .on("close", () => {
              Hooker.emit("download-end", {}).then(() => {
                resolve();
              });
            })
            .on("error", (e) => {
              Hooker.emit("download-end", { error: e }).then(() => {
                reject(e);
              });
            });
        });
      });
  }

  getLanguageCodes() {
    return Reflect.ownKeys(config.languageMap);
  }

  getLanguageStatus(lang = "en-us") {
    lang = util.getCrowdinLangCode(lang);
    if (lang) {
      return this._v1.getLanguageStatus(lang);
    } else {
      return Promise.reject("language can not found");
    }
  }

  getTranslateStatus() {
    return this._v1.getTranslateStatus();
  }

  getKeysList() {
    return this.getProjectId().then((projectId) => {
      return this._v2.getKeysList({ projectId });
    });
  }

  getFileTranslateStatus(fileName) {
    return this.getProjectId().then((projectId) => {
      return this.getFileId(fileName).then((fileId) => {
        return this._v2.getFileTranslateStatus(projectId, fileId);
      });
    });
  }
}

module.exports = Crowdin;
