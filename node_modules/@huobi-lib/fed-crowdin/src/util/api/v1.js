
const fs = require("fs");
const got = require('got');
const mime = require('mime-types');
const FormData = require('form-data');

const APIS = {
    download({ project, lang = 'all' }) {
        return `https://api.crowdin.com/api/project/${project}/download/${lang}.zip`;
    },
    status(project) {
        return `https://api.crowdin.com/api/project/${project}/language-status`;
    },
    translateStatus(project) {
        return `https://api.crowdin.com/api/project/${project}/status`;
    },
    update(project) {
        return `https://api.crowdin.com/api/project/${project}/update-file`;
    },
    projectDetail(project) {
        return `https://api.crowdin.com/api/project/${project}/info`;
    },
    built(project) {
        return `https://api.crowdin.com/api/project/${project}/export`;
    },
    add(project) {
        return `https://api.crowdin.com/api/project/${project}/add-file`;
    },
    exportFile(project) {
        return `https://api.crowdin.com/api/project/${project}/export-file`;
    },
    deleteFile(project) {
        return `https://api.crowdin.com/api/project/${project}/delete-file`;
    },
    uploadTranslation(project) {
        return `https://api.crowdin.com/api/project/${project}/upload-translation`;
    },
    updateLanguagesSet(project) {
        return `https://api.crowdin.com/api/project/${project}/edit-project`;
    },
    langList() {
        return `https://api.crowdin.com/api/supported-languages`;
    },
    addFolder(project) {
        return `https://api.crowdin.com/api/project/${project}/add-directory`;
    }
};

class Request {
    constructor() {
        this._headers = {
        };
    }

    get(url, parameter) {
        return got(url, {
            headers: this._headers,
            isStream: false,
            searchParams: parameter
        });
    }

    post(url, { form, query = {} }) {
        return got(url, {
            headers: this._headers,
            method: 'post',
            searchParams: query,
            form
        });
    }

    postFormData(url, { formData, query = {} }) {
        return got(url, {
            headers: this._headers,
            method: 'post',
            searchParams: query,
            body: formData
        });
    }

    getFormData(form = {}) {
        const formData = new FormData();
        Reflect.ownKeys(form).forEach(a => {
            formData.append(a, form[a]);
        });
        return formData;
    }

    getStream(url, parameter) {
        return got(url, {
            headers: this._headers,
            searchParams: parameter,
            isStream: true
        });
    }
}

class Crowdin {
    constructor({ project, key }) {
        this.project = project;
        this.key = key;
        this.request = new Request();
    }

    _addAndUpdate(fileOptions, ops = {}, add = false) {
        const formData = new FormData();
        Reflect.ownKeys(ops || {}).forEach(key => {
            formData.append(key, ops[key]);
        });
        fileOptions.map(fileOption => Object.assign({
            path: "",
            pattern: '%original_file_name%',
            title: "",
            fileName: ""
        }, fileOption)).forEach(fileOption => {
            // formData[`export_patterns[${fileOption.fileName}]`] = fileOption.pattern;
            formData.append(`export_patterns[${fileOption.fileName}]`,fileOption.pattern);
            formData.append(`files[${fileOption.fileName}]`, fileOption.fileStream, {
                filename: fileOption.fileName,
                contentType: mime.lookup(fileOption.fileName)
            });
        });
        let url = add ? APIS.add(this.project) : APIS.update(this.project);
        return this.request.postFormData(url, {
            formData,
            query: {
                json: 'json',
                key: this.key
            }
        }).then(({ body }) => JSON.parse(body));
    }

    _addAndUpdateByBuffer(fileOptions, ops = {}, add = false) {
        const formData = new FormData();
        Reflect.ownKeys(ops || {}).forEach(key => {
            formData.append(key, ops[key]);
        });
        fileOptions.map(fileOption => Object.assign({
            fileStream: "",
            fileName: "",
            pattern: '%original_file_name%',
            title: ""
        }, fileOption)).forEach(fileOption => {
            formData.append(`export_patterns[${fileOption.fileName}]`, fileOption.pattern);
            formData.append(`files[${fileOption.fileName}]`, fileOption.fileStream, {
                filename: fileOption.fileName,
                contentType: mime.lookup(fileOption.fileName)
            });
        });
        let url = add ? APIS.add(this.project) : APIS.update(this.project);
        return this.request.postFormData(url, {
            formData,
            query: {
                json: 'json',
                key: this.key
            }
        }).then(({ body }) => JSON.parse(body));
    }

    _uploadTranslationByBuffer(fileOptions, ops) {
        const formData = new FormData();
        Reflect.ownKeys(ops || {}).forEach(key => {
            formData.append(key, ops[key]);
        });
        fileOptions.map(fileOption => Object.assign({
            fileStream: "",
            fileName: ""
        }, fileOption)).forEach(fileOption => {
            formData.append(`files[${fileOption.fileName}]`, fileOption.fileStream, {
                filename: fileOption.fileName,
                contentType: mime.lookup(fileOption.fileName)
            });
        });
        return this.request.postFormData(APIS.uploadTranslation(this.project), {
            formData,
            query: {
                json: 'json',
                key: this.key
            }
        }).then(({ body }) => JSON.parse(body));
    }

    getDownloadStream(lang = 'all') {
        return this.request.getStream(APIS.download({ project: this.project, lang }), {
            key: this.key
        });
    }

    getLanguageStatus(lang = 'en') {
        return this.request.post(APIS.status(this.project), {
            form: { key: this.key, language: lang },
            query: { json: 'json' }
        }).then(({ body }) => JSON.parse(body));
    }

    getProjectDetail() {
        return this.request.post(APIS.projectDetail(this.project), {
            form: { key: this.key },
            query: { json: 'json' }
        }).then(({ body }) => {
            return JSON.parse(body);
        });
    }

    getTranslateStatus() {
        return this.request.post(APIS.translateStatus(this.project), {
            form: { key: this.key },
            query: { json: 'json' }
        }).then(({ body }) => {
            return JSON.parse(body);
        });
    }

    updateFile(localPath, ops = { pattern: '%original_file_name%' }) {
        return this.updateFiles([Object.assign({ path: localPath }, ops)]);
    }

    updateFiles(fileOptions, ops = {}) {
        return this._addAndUpdate(fileOptions, ops, false);
    }

    updateFilesByBuffer(fileOptions, ops = {}) {
        return this._addAndUpdateByBuffer(fileOptions, ops, false);
    }

    updateFileByBuffer(fileName, fileStream, ops = { pattern: '%original_file_name%' }, other = {}) {
        return this.updateFilesByBuffer([Object.assign({
            fileName,
            fileStream
        }, ops)], other);
    }

    addFile(localPath, ops = { pattern: '%original_file_name%' }) {
        return this.addFiles([Object.assign({ path: localPath }, ops)]);
    }

    addFiles(fileOptions, ops = {}) {
        return this._addAndUpdate(fileOptions, ops, true);
    }

    addFilesByBuffer(fileOptions, ops = {}) {
        return this._addAndUpdateByBuffer(fileOptions, ops, true);
    }

    addFileByBuffer(fileName, fileStream, ops = { pattern: '%original_file_name%' }, other = {}) {
        return this.addFilesByBuffer([Object.assign({
            fileName,
            fileStream
        }, ops)], other);
    }

    uploadTransitionsByBuffer(fileOptions, language, other = {}) {
        return this._uploadTranslationByBuffer(fileOptions, Object.assign({ language }, other || {}));
    }

    uploadTransitionByBuffer(fileName, fileStream, language, other = {}) {
        return this.uploadTransitionsByBuffer([{
            fileName,
            fileStream
        }], language, other);
    }

    exportFile(file, etag, option) {//option{file,language...}export_translated_only ,export_approved_only
        if (etag) {
            return this.request.get(APIS.exportFile(this.project), { "If-None-Match": etag }, Object.assign({
                file,
                key: this.key,
                json: "json"
            }, option));
        } else {
            return this.request.get(APIS.exportFile(this.project), {}, Object.assign({
                file,
                key: this.key,
                json: "json"
            }, option));
        }
    }

    exportFileTo(file, etag, localPath, option) {
        return this.exportFile(file, etag, option).then(({ body }) => new file(localPath).write(body));
    }

    deleteFile(file, branch) {
        let form = { file, key: this.key };
        if (branch) {
            form.branch = branch;
        }
        return Request.post(APIS.deleteFile(this.project), {
            form,
            query: { json: 'json' }
        }).then(info => JSON.parse(info));
    }

    built(branch = "") {
        let query = { key: this.key, json: "json" };
        if (branch) {
            query.branch = branch;
        }
        return this.request.get(APIS.built(this.project), query).then(({ body }) => {
            return JSON.parse(body);
        });
    }

    updateLanguagesSet(languages, ops) {
        let formData = Object.assign({ key: this.key }, ops);
        languages.forEach((language, index) => {
            formData[`languages[${index}]`] = language;
        });
        return this.request.post(APIS.updateLanguagesSet(this.project), {
            formData,
            query: { json: 'json' }
        }).then(info => JSON.parse(info));
    }

    getSupportLanguageList() {
        return Request.get(APIS.langList(), { json: "json" }).then(a => JSON.parse(a));
    }
}

module.exports = Crowdin;