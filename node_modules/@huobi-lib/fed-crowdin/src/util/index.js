const fs = require("fs");
const os = require("os");
const got = require("got");
const crypto = require("crypto");
const unzip = require("unzipper");
const iconv = require("iconv-lite");
const Hash = require("ada-util/src/md5");
const Path = require("path");
const { File } = require("ada-util");
const beautify = require("js-beautify").html_beautify;
const minify = require("html-minifier").minify;
const config = require("../config/index");
const chalk = require("chalk");
const cliui = require("cliui");
const ora = require("ora");
const ignore = require("ignore");
const cliProgress = require("cli-progress");

const util = {
  lib: { chalk, cliui, ora, cliProgress },
  request: {
    invoke(...args) {
      return got(...args);
    },
    get(url, parameter) {
      return got(url, {
        headers: this._headers,
        isStream: false,
        searchParams: parameter,
      });
    },
    post(url, { form, query = {} }) {
      return got(url, {
        headers: this._headers,
        method: "post",
        searchParams: query,
        form,
      });
    },
    postFormData(url, { formData, query = {} }) {
      return got(url, {
        headers: this._headers,
        method: "post",
        searchParams: query,
        body: formData,
      });
    },
    postBody(url, { body, query = {} }) {
      return got(url, {
        headers: this._headers,
        method: "post",
        searchParams: query,
        body,
      });
    },
    getStream(url, parameter) {
      return got(url, {
        headers: this._headers,
        searchParams: parameter,
        isStream: true,
      });
    },
  },
  cleanKeyValue(value) {
    if (value) {
      let t = value
        .trim()
        .replace(/\"/g, "&quot;")
        .replace(/\u2028/g, "")
        .replace(/^\s+|\s+$/g, "");
      return t;
    } else {
      return value;
    }
  },
  getKeyCode(str) {
    return `HB${Hash.md5(str + "")}`.substring(0, 10);
  },
  getLocalLangCodes() {
    return Reflect.ownKeys(config.languageMap);
  },
  getCrowdinLangCodes() {
    return Reflect.ownKeys(config.languageMap).map(
      (a) => config.languageMap[a].crowdin
    );
  },
  getLocalLangCode(crowdinLangCode) {
    return (
      Reflect.ownKeys(config.languageMap).filter((key) => {
        let info = config.languageMap[key];
        return info.crowdin === crowdinLangCode;
      })[0] || null
    );
  },
  getCrowdinLangCode(localLang) {
    let t = config.languageMap;
    if (t[localLang]) {
      return t[localLang].crowdin;
    } else {
      return null;
    }
  },
  cleanKeyValue(value) {
    if (value) {
      let t = value
        .trim()
        .replace(/\"/g, "&quot;")
        .replace(/\u2028/g, "")
        .replace(/^\s+|\s+$/g, "");
      return t;
    } else {
      return value;
    }
  },
  formatDate(date, format = "yyyy-MM-dd hh:mm:ss") {
    let o = {
      "M+": date.getMonth() + 1,
      "d+": date.getDate(),
      "h+": date.getHours(),
      "m+": date.getMinutes(),
      "s+": date.getSeconds(),
      "q+": Math.floor((date.getMonth() + 3) / 3),
      S: date.getMilliseconds(),
    };
    if (/(y+)/g.test(format)) {
      format = format.replace(
        RegExp.$1,
        (date.getFullYear() + "").substr(4 - RegExp.$1.length)
      );
    }
    Reflect.ownKeys(o).forEach((k) => {
      if (new RegExp("(" + k + ")").test(format)) {
        format = format.replace(
          RegExp.$1,
          RegExp.$1.length == 1
            ? o[k]
            : ("00" + o[k]).substr(("" + o[k]).length)
        );
      }
    });
    return format;
  },
  getConfigFromFile() {
    let path = Path.resolve(process.cwd(), "./crowdin.hb.js");
    if (new File(path).isExists()) {
      return require(path);
    } else {
      console.log("file crowdin.hb.js is not exist,use the default config");
      return {};
    }
  },
  exec(command, option) {
    return new Promise((resolve, reject) => {
      let exec = require("child_process").exec;
      exec(command, option, function (error, stdout, stderr) {
        if (error) {
          reject(error);
        } else {
          resolve(stdout);
        }
      });
    });
  },
  beautyHTML(code) {
    return beautify(code, {
      brace_style: "collapse",
      break_chained_methods: false,
      comma_first: false,
      e4x: false,
      end_with_newline: false,
      indent_char: " ",
      indent_inner_html: false,
      indent_scripts: "normal",
      indent_size: "4",
      jslint_happy: false,
      keep_array_indentation: false,
      max_preserve_newlines: "5",
      preserve_newlines: true,
      space_before_conditional: true,
      unescape_strings: false,
      wrap_line_length: "0",
    });
  },
  minifyHTML(content) {
    return minify(content, {
      removeComments: true,
      collapseWhitespace: true,
      minifyJS: true,
      quoteCharacter: "'",
      minifyCSS: true,
    });
  },
  diffArray(a = [], b = []) {
    let add = [],
      remove = [];
    if (!Array.isArray(a)) {
      a = [];
    }
    if (!Array.isArray(b)) {
      b = [];
    }
    a.forEach((_a) => {
      if (!b.includes(_a)) {
        remove.push(_a);
      }
    });
    b.forEach((_b) => {
      if (!a.includes(_b)) {
        add.push(_b);
      }
    });
    return { add, remove };
  },
  getUserName() {
    return os.userInfo().username;
  },
  getBranchName() {
    return this.exec("git branch", {
      cwd: config.basePath,
    }).then((name) => {
      let _name = name
        .split(os.EOL)
        .filter((a) => a.indexOf("*") === 0)
        .map((a) => a.substring(2))[0];
      if (config._dev) {
        _name = config._devBranch || "BRANCH_T88999";
      }
      if (_name) {
        if (config.gitBranchPattern.test(_name)) {
          _name = _name.split("_")[1];
          return `${config.filePrefix}_${_name}`;
        } else if (_name === "master") {
          return `master`;
        }
      }
    });
  },
  getTaskFileName() {
    return this.getBranchName().then((name) => {
      return `${name}.json`;
    });
  },
  getDingdingSign(secret) {
    let time = new Date().getTime();
    return {
      time,
      sign: encodeURIComponent(
        crypto
          .createHmac("SHA256", secret)
          .update(`${time}\n${secret}`, "utf8")
          .digest("base64")
      ),
    };
  },
  formatLanguageStatus(files) {
    files.filter((a) => a.node_type === "file");
    if (files.length > 0) {
      let ui = cliui();
      ui.div(
        { text: chalk("Key").green, width: 20 },
        { text: chalk("Translated:").green, width: 15 },
        { text: chalk("Words:").green, width: 15 },
        { text: chalk("Percent:").green, width: 10 }
      );
      files.forEach(({ name, translated, words }) => {
        ui.div(
          { text: name, width: 20 },
          { text: translated, width: 15 },
          { text: words, width: 15 },
          {
            text: chalk(parseInt((translated / words) * 100) + "%").green,
            width: 10,
          }
        );
      });
      console.log(ui.toString());
    } else {
      console.log("noting to display");
    }
  },
  formatTranslateStatus(list) {
    if (list.length > 0) {
      let ui = cliui();
      ui.div(
        { text: chalk("Name").green, width: 25 },
        { text: chalk("Code:").green, width: 10 },
        { text: chalk("Translated:").green, width: 15 },
        { text: chalk("Words:").green, width: 10 },
        { text: chalk("Percent:").green, width: 10 }
      );
      list.forEach(
        ({ name, code, words_translated, words, translated_progress }) => {
          ui.div(
            { text: name, width: 25 },
            { text: code, width: 10 },
            { text: words_translated, width: 15 },
            { text: words, width: 10 },
            { text: chalk(translated_progress + "%").green, width: 10 }
          );
        }
      );
      console.log(ui.toString());
    } else {
      console.log("noting to display");
    }
  },
  formatFileTranslateStatus(list) {
    if (list.length > 0) {
      list = list.map((a) => a.data);
      let ui = cliui();
      ui.div(
        { text: chalk("Name").green, width: 15 },
        { text: chalk("Lang").green, width: 15 },
        { text: chalk("Words:").green, width: 10 },
        { text: chalk("Phrases:").green, width: 10 },
        { text: chalk("Progress:").green, width: 10 }
      );
      list.forEach(({ languageId, words, phrases, translationProgress }) => {
        ui.div(
          { text: languageId, width: 15 },
          { text: this.getLocalLangCode(languageId) || "--", width: 15 },
          { text: words.total, width: 10 },
          { text: phrases.total, width: 10 },
          { text: chalk(translationProgress + "%").green, width: 10 }
        );
      });
      console.log(ui.toString());
    } else {
      console.log("noting to display");
    }
  },
  unzip(_zipPath, output) {
    return new Promise((resolve, reject) => {
      let p = Promise.resolve();
      p = p.then(() => {
        if (new File(output).exist) {
          return new File(output).empty();
        }
      });
      fs.createReadStream(_zipPath)
        .pipe(unzip.Parse())
        .on("entry", (entry) => {
          if (entry.type === "File") {
            if ([".json", ".csv"].includes(Path.extname(entry.path))) {
              p = p.then(() => {
                return entry.buffer().then((content) => {
                  return new File(Path.resolve(output, entry.path)).write(
                    iconv.decode(content, "utf8").toString()
                  );
                });
              });
            }
          } else {
            entry.autodrain();
          }
        })
        .on("close", () => {
          p.then(resolve, resolve);
        })
        .on("error", reject);
    });
  },
  getGkeysPaths() {
    const ig = ignore().add(config.gkeysPathIgnore || []);
    return new File(config.basePath)
      .getSubFilePaths()
      .then((paths) => {
        return ig.filter(paths);
      })
      .then((paths) => {
        let r = [];
        return paths
          .reduce((a, path) => {
            return a.then(() => {
              let t = Path.resolve(config.basePath, path);
              return new File(t).isFolder().then((isFolder) => {
                if (isFolder) {
                  r.push(t);
                }
              });
            });
          }, Promise.resolve())
          .then(() => {
            return r;
          });
      });
  },
  getGkeysFilePaths() {
    return this.getGkeysPaths().then((paths) => {
      let r = [];
      return paths
        .reduce((a, path) => {
          return a.then(() => {
            return new File(path).getAllSubFilePaths().then((a) => {
              r = r.concat(
                a.filter((b) => {
                  return config.gkeysSuffix.includes(Path.extname(b));
                })
              );
            });
          });
        }, Promise.resolve())
        .then(() => r);
    });
  },
  healthCheck() {
    if (new File(Path.resolve(config.basePath, "./crowdin.hb.js")).exist) {
      if (config.project && config.key) {
        return true;
      }
      if (config.id) {
        return true;
      } else {
        console.log("crowdin project name or key is empty");
        return false;
      }
    } else {
      console.log("file crowdin.hb.js is not exist");
      return false;
    }
  },
  reduplicate(array) {
    let t = new Set();
    array.forEach((a) => t.add(a));
    return [...t];
  },
  async sogouTranslate(keys, toLang, formLang = "zh-CHS") {
    let r = {};
    let total = keys.length;
    const transBar = new this.lib.cliProgress.SingleBar({
      format:
        "Auto Translating " +
        toLang +
        ": [{bar}] {percentage}% | ETA: {eta}s | {value}/{total}",
    });
    transBar.start(total, 0);
    for (var i = 0; i < total; i++) {
      try {
        let org = keys[i];
        let res = await __getSogouTranslate(
          org,
          toLang,
          formLang,
          this.request
        );
        let trans = __clearSogouTrans(org, res.translation, this);
        r[org] = trans;
      } catch (e) {
        console.error(keys[i], e);
      }
      transBar.update(i + 1);
    }
    transBar.stop();
    return r;
  },
};

const SOGOU_PID = "c9879bd2f5f67796e40cf49d1ee38e9e";
const SOGOU_KEY = "d7d05caede7bb8201c8d5fbc28757eb8";
function __getSogouTranslate(str, toLang, fromLang, request) {
  let tmpData = {
    q: str,
    from: fromLang,
    to: toLang,
    pid: SOGOU_PID,
    salt: "1214",
    sign: undefined,
  };
  tmpData.sign = Hash.md5(
    [tmpData.pid, tmpData.q, tmpData.salt, SOGOU_KEY].join("")
  );

  return new Promise((res, rej) => {
    request
      .post("http://fanyi.sogou.com/reventondc/api/sogouTranslate", {
        form: tmpData,
      })
      .then(({ body }) => {
        let data = JSON.parse(body);
        if (data.errorCode == "0") {
          setTimeout(() => {
            res(data);
          }, 60);
        } else {
          rej(data);
        }
      })
      .catch(rej);
  });
}
function __clearSogouTrans(org, trans, util) {
  trans = util.cleanKeyValue(trans);
  org = util.cleanKeyValue(org);
  if (!org.match(/[\.。]$/)) {
    trans = trans.replace(/[\.。]$/, "");
  }
  return trans;
}

module.exports = util;
