const os = require("os");
const fs = require("fs");
const util = require("./util");
const Path = require("path");
const { File, SyncFile } = require("ada-util");
const config = require("./config/index");
const Crowdin = require("./util/api/index");
const Group = require("./util/group");
const Cache = require("./util/cache");
const Hooker = require("./hooker");
const Template = require("art-template");
const chalk = require("chalk");

const crowdin = new Crowdin({
  projectId: config.id,
  project: config.project,
  key: config.key,
});

class Outputter {
  constructor({ keyFiles }) {
    this.path = config.outputPath;
    this._keyFiles = keyFiles;
    this._defaultTranslate = Cache(() => {
      return this.getTranslate(config.defaultLang.lang);
    });
    this._defaultLongTranslate = Cache(() => {
      return this.getLongTranslate(config.defaultLang.lang);
    });
    this._keys = Cache(() => {
      return this._keyFiles.getKeys();
    });
    if (this.path) {
      new File(this.path).mkdir();
    }
  }

  _getKeys() {
    return this._keys.get().then(({ result }) => {
      return result;
    });
  }

  _getDefaultTranslate() {
    return this._defaultTranslate.get().then(({ result }) => {
      return result;
    });
  }

  _getDefaultLangTranslate() {
    return this._defaultLongTranslate.get().then(({ result }) => {
      return result;
    });
  }

  _setVariable(map, config) {
    let path = require("path").resolve(config.basePath, "./hbcloud.langs.js");
    if (new File(path).exist) {
      let LANGUAGEMAP = require(path);
      let supportLangList = Reflect.ownKeys(map);
      let browserLangList = [];
      supportLangList.forEach((lang) => {
        let bn = LANGUAGEMAP[lang].browser;
        if (bn) {
          browserLangList = browserLangList.concat(bn.split(","));
        }
      });
      let languageList = {};
      supportLangList.forEach((lang) => {
        languageList[lang] = LANGUAGEMAP[lang].name;
      });
      supportLangList.forEach((lang) => {
        Object.assign(map[lang], {
          hbc_browserLangList: JSON.stringify(browserLangList),
          hbc_supportLangList: JSON.stringify(supportLangList),
          hbc_languageList: JSON.stringify(languageList),
        });
      });
    }
    return map;
  }

  getLongTranslate(lang) {
    let path = Path.resolve(config.longKeyPath, `./${lang}`);
    if (config.longKeyPath && new File(path).exist) {
      return new File(path).getAllSubFilePaths().then((paths) => {
        let translate = {};
        return paths
          .reduce((a, path) => {
            return a.then(() => {
              let [key] = Path.basename(path).split(".");
              return new File(path).read().then((content) => {
                translate[key] = util.minifyHTML(content).replace(/\n/g, "");
              });
            });
          }, Promise.resolve())
          .then(() => {
            if (lang !== config.defaultLang.lang) {
              return this._getDefaultLangTranslate().then((def) => {
                Reflect.ownKeys(def).forEach((key) => {
                  let value = def[key];
                  if (!value) {
                    translate[key] = value;
                  }
                });
                return translate;
              });
            } else {
              return translate;
            }
          });
      });
    } else {
      return Promise.resolve({});
    }
  }

  getTranslate(lang) {
    let a = Path.resolve(
      config._cache_translate_unzip_path,
      `./${util.getCrowdinLangCode(lang)}`
    );
    if (new File(a).exist) {
      let translate = {};
      return new File(a)
        .getAllSubFilePaths()
        .then((paths) => {
          return paths
            .filter(
              (a) => Path.extname(a) === ".json" || Path.extname(a) === ".csv"
            )
            .reduce((a, path) => {
              return a.then(() => {
                return new File(path).read().then((content) => {
                  if (path.slice(-3) === "csv") {
                    let res = content.replace(/\r|"/g, "").split("\n");
                    res = res.reduce((acc, next) => {
                      const [k, v] = next.split(",");
                      if (k) {
                        acc[k] = v;
                      }
                      return acc;
                    }, {});
                    Object.assign(translate, res || {});
                  } else {
                    Object.assign(translate, JSON.parse(content) || {});
                  }
                });
              });
            }, Promise.resolve());
        })
        .then(() => {
          return this._getKeys().then((keys) => {
            return this._keyFiles.getKeyCode().then((keyCode) => {
              if (
                lang !== config.defaultLang.lang &&
                !config.defaultLang.exclude.includes(lang)
              ) {
                let def = this._getDefaultTranslate(),
                  ot = {};
                keys.forEach((key) => {
                  let code = keyCode[key];
                  let value = translate[code];
                  if (value === key) {
                    value = def[code];
                  }
                  ot[key] = value;
                });
                return ot;
              } else {
                let ot = {};
                keys.forEach((key) => {
                  ot[key] = translate[keyCode[key]];
                });
                return ot;
              }
            });
          });
        })
        .then((r) => {
          return this.getLongTranslate(lang)
            .then((m) => {
              return Object.assign(r, m);
            })
            .then((r) => {
              let rr = {};
              Reflect.ownKeys(r).forEach((a) => {
                rr[a] = util.cleanKeyValue(r[a]);
              });
              return rr;
            });
        });
    } else {
      return Promise.resolve({});
    }
  }

  cleanDist() {
    if (this.path) {
      return new File(this.path).remove();
    } else {
      return Promise.resolve();
    }
  }

  getOutputVariable() {
    let vars = config.languageMapVars;
    let map = config.languageMap;
    Reflect.ownKeys(map).forEach((langCode) => {
      let current = map[langCode];
      Reflect.ownKeys(current).forEach((key) => {
        let value = current[key];
        if (value.replace) {
          current[key] = value.replace(/{#(.*?)#}/g, (str) => {
            let _val = str.substring(2, str.length - 2).trim();
            if (vars[_val] !== undefined) {
              return vars[_val];
            } else if (current[_val] !== undefined) {
              return current[_val];
            } else {
              return _val;
            }
          });
        }
      });
      if (config.languageMapGenerater) {
        let r = config.languageMapGenerater.call(current, vars);
        if (r) {
          Object.assign(current, r);
        }
      }
    });
    return this._setVariable(map, config);
  }

  outputVariable() {
    if (this.path) {
      return Hooker.emit("output-variable", {
        variable: this.getOutputVariable(),
      }).then(({ result, data }) => {
        let t = result || data.variable;
        return new File(Path.resolve(this.path, "./variable.json")).write(
          JSON.stringify(t, null, 4)
        );
      });
    } else {
      return Promise.resolve();
    }
  }

  output() {
    return this.cleanDist().then(() => {
      if (this.path) {
        return util
          .getLocalLangCodes()
          .reduce((a, lang) => {
            return a.then(() => {
              return this.getTranslate(lang).then((translate) => {
                let fileName = `${lang}.json`;
                return Hooker.emit("output-translate", {
                  fileName,
                  lang,
                  translate,
                }).then(({ result, data }) => {
                  translate = result || data.translate;
                  return new File(Path.resolve(this.path, fileName)).write(
                    JSON.stringify({ [lang]: translate }, null, 4)
                  );
                });
              });
            });
          }, Promise.resolve())
          .then(() => {
            return this.outputVariable();
          });
      } else {
        return Promise.resolve();
      }
    });
  }
}

class Keys {
  constructor() {
    this._path = config._cache_keys_path;
    this._keyCode = {};
  }

  _getFilePath(fileName) {
    return Path.resolve(this._path, `./${fileName}`);
  }

  getFileList() {
    if (new File(this._path).exist) {
      return new File(this._path).getAllSubFilePaths().then((list) => {
        return list.filter((a) => [".json", ".csv"].includes(Path.extname(a)));
      });
    } else {
      return Promise.resolve([]);
    }
  }

  getList() {
    return this.getFileList().then((list) => {
      let r = [];
      return list
        .reduce((a, f) => {
          return a.then(() => {
            return new File(f).info().then((a) => {
              r.push({
                name: Path.basename(f),
                time: a.mtimeMs,
              });
            });
          });
        }, Promise.resolve())
        .then(() => r);
    });
  }

  getKeyCode() {
    if (Object.keys(this._keyCode).length) {
      return Promise.resolve(this._keyCode);
    } else {
      let keyCode = {};
      return this.getFileList().then((files) => {
        return files
          .reduce((acc, next) => {
            return acc.then(() => {
              return new File(next).read().then((content) => {
                if (next.slice(-3) === "csv") {
                  content = content.replace(/\r|"/g, "").split("\n");
                  content = content.reduce((acc, next) => {
                    const [k, v] = next.split(",");
                    if (k) {
                      acc[k] = v;
                    }
                    return acc;
                  }, {});
                } else {
                  content = JSON.parse(content);
                }
                const ko = Object.keys(content).forEach((k) => {
                  keyCode[content[k]] = k;
                });
                Object.assign(keyCode, ko);
              });
            });
          }, Promise.resolve())
          .then(() => {
            this._keyCode = keyCode;
            return keyCode;
          });
      });
    }
  }

  hasFile(fileName) {
    fileName = this._getFilePath(fileName);
    return new File(fileName).exist;
  }

  getContent(fileName) {
    return new File(this._getFilePath(fileName)).read();
  }

  getContentObject(fileName) {
    return this.getContent(fileName).then((content) => {
      let res = {};
      try {
        if (fileName.slice(-3) === "csv") {
          res = content.replace(/\r|"/g, "").split("\n");
          res = res.reduce((acc, next) => {
            const [k, v] = next.split(",");
            if (k) {
              acc[k] = v;
            }
            return acc;
          }, {});
        } else {
          res = JSON.parse(content);
        }
      } catch (e) {}
      return res;
    });
  }

  setContent(fileName, content, time) {
    return new File(this._getFilePath(fileName)).write(content).then(() => {
      return new Promise((resolve, reject) => {
        fs.utimes(
          this._getFilePath(fileName),
          new Date().getTime(),
          new Date(time),
          (err) => {
            if (err) {
              reject(err);
            } else {
              resolve();
            }
          }
        );
      });
    });
  }

  getHash(fileName) {
    return new File(this._getFilePath(fileName)).hash();
  }

  remove(fileName) {
    return new File(this._getFilePath(fileName)).remove();
  }

  getKeys({ fileName = "", departs = [] } = {}) {
    if (fileName) {
      let file = new File(this._getFilePath(fileName));
      if (file.exist) {
        return file.read().then((content) => {
          let info = JSON.parse(content);
          return Reflect.ownKeys(info).map((a) => info[a]);
        });
      } else {
        return Promise.resolve(null);
      }
    } else {
      return this.getFileList().then((files) => {
        let keys = [];
        return new Group(
          files.filter((a) => !departs.includes(Path.basename(a)))
        )
          .queue((_path) => {
            let fileName = Path.basename(_path);
            return this.getContentObject(fileName).then((object) => {
              let info = Reflect.ownKeys(object).map((a) => object[a]);
              keys = keys.concat(info);
            });
          })
          .then(() => {
            return keys;
          });
      });
    }
  }

  getRawKeys(fileName) {
    if (fileName) {
      return new File(this._getFilePath(fileName)).read().then((content) => {
        return JSON.parse(content);
      });
    } else {
      return this.getFileList().then((files) => {
        let keys = {};
        return new Group(files)
          .queue((_path) => {
            let fileName = Path.basename(_path);
            return this.getContentObject(fileName).then((object) => {
              let info = Reflect.ownKeys(object).map((a) => object[a]);
              Object.assign(keys, info);
            });
          })
          .then(() => {
            return keys;
          });
      });
    }
  }

  output(path) {
    let file = new File(path),
      ps = Promise.resolve();
    if (file.exist) {
      ps = ps.then(() => {
        return file.empty();
      });
    }
    return ps
      .then(() => {
        return this.getFileList();
      })
      .then((files) => {
        return new Group(files).queue((_path) => {
          let fileName = Path.basename(_path);
          return this.getContentObject(fileName).then((object) => {
            let info = Reflect.ownKeys(object).map((a) => object[a]);
            return new File(Path.resolve(path, `./${fileName}`)).write(
              JSON.stringify(info, null, 4)
            );
          });
        });
      });
  }
}

class Robot {
  send({ add, remove, comment }) {
    let removeInfo = {},
      addInfo = {};
    if (remove.length > 3) {
      removeInfo.items = remove.filter((item, index) => index < 2);
      removeInfo.isEnd = false;
      removeInfo.total = remove.length;
      removeInfo.last = remove[remove.length - 1];
    } else {
      removeInfo.items = remove;
      removeInfo.isEnd = true;
      removeInfo.total = remove.length;
    }
    if (add.length > 3) {
      addInfo.items = add.filter((item, index) => index < 2);
      addInfo.isEnd = false;
      addInfo.total = add.length;
      addInfo.last = add[add.length - 1];
    } else {
      addInfo.items = add;
      addInfo.isEnd = true;
      addInfo.total = add.length;
    }
    return Hooker.emit("dingding-start")
      .then(() => {
        return util.getBranchName();
      })
      .then((branchName) => {
        let [name] = branchName.split("."),
          task = "";
        if (name !== "master") {
          task = name.split("_").pop();
        }
        return {
          branchName: name,
          taskName: task,
          project: config.project,
          userName: os.userInfo().username,
          removeInfo,
          addInfo,
          comment,
          message: null,
        };
      })
      .then((info) => {
        return Hooker.emit("dingding-message", { info }).then(
          ({ result, data }) => result || data.info
        );
      })
      .then((info) => {
        let { message } = info;
        let url = config.dingdingRobotPath;
        if (config.dingdingRobotScret) {
          let { time, sign } = util.getDingdingSign(config.dingdingRobotScret);
          url = `${url}&timestamp=${time}&sign=${sign}`;
        }
        if (!message) {
          message = {
            msgtype: "markdown",
            markdown: {
              title: "Crowdin有更新",
              text: Template.compile(
                new SyncFile(
                  Path.resolve(__dirname, "./config/dingding.md")
                ).read()
              )(info),
            },
          };
        }
        return util.request.invoke(url, {
          headers: { "Content-Type": "application/json" },
          method: "post",
          body: JSON.stringify(message),
        });
      })
      .then(({ body }) => {
        try {
          let info = JSON.parse(body);
          if (info.errcode == 0) {
            return Hooker.emit("dingding-end", {});
          } else {
            return Hooker.emit("dingding-end", { error: info });
          }
        } catch (e) {
          return Hooker.emit("dingding-end", { error: e });
        }
      })
      .catch((e) => {
        return Hooker.emit("dingding-end", { error: e });
      });
  }
}

class Migrate {
  constructor({ project, key, local }) {
    this._local = local;
    this._target = new Crowdin({ project, key });
    this._targetFileName = config.migrateTargetFileName;
  }

  check() {
    let hasTargetFile = false;
    return this._target
      .getProjectDetail()
      .then((info) => {
        hasTargetFile = info.files.find((a) => a.name === this._targetFileName);
      })
      .then(() => {
        if (!hasTargetFile) {
          return Promise.resolve();
        } else {
          return Promise.reject(
            `target cannot contain "${this._targetFileName}" key file`
          );
        }
      })
      .catch((e) => {
        return Promise.reject(`maybe key or project can not match :(`);
      });
  }

  uploadTranslation({ lang, keys }) {
    let path = Path.resolve(config._cache_translate_unzip_path, `./${lang}`);
    let all = {};
    return new File(path)
      .getAllSubFilePaths()
      .then((paths) => {
        return paths.reduce((a, path) => {
          return a.then(() => {
            return new File(path).read().then((content) => {
              Object.assign(all, JSON.parse(content));
            });
          });
        }, Promise.resolve());
      })
      .then(() => {
        let data = {};
        keys.forEach((key) => {
          let code = util.getKeyCode(key);
          data[key] = all[code];
        });
        return this._target.uploadTranslation({
          fileName: this._targetFileName,
          langCode: lang,
          data,
        });
      });
  }

  uploadTranslations() {
    return this.uploadKeys().then((keys) => {
      return this.getTargetLanguages().then((languages) => {
        return languages.reduce((a, language) => {
          return a.then(() => {
            return this.uploadTranslation({ lang: language, keys });
          });
        }, Promise.resolve());
      });
    });
  }

  uploadKeys() {
    return util
      .getGkeysPaths()
      .then((paths) => {
        return this._local.getAllKeyInfosFromPaths(paths, config.gkeysSuffix);
      })
      .then((a) => {
        let keys = Reflect.ownKeys(a);
        return this._target
          .addOrUpdateFile({ fileName: this._targetFileName, data: keys })
          .then(() => keys);
      });
  }

  getTargetLanguages() {
    return crowdin.getProjectDetail().then(({ languages }) => {
      let langs = languages.map((a) => a.code);
      return this._target.getProjectDetail().then((info) => {
        return langs.filter((a) => info.languages.find((b) => b.code === a));
      });
    });
  }

  invoke() {
    new SyncFile(config._cache_translate_path).make();
    return crowdin
      .downloadLanguagePack(config._cache_translate_path)
      .then(() => {
        return util.unzip(
          config._cache_translate_path,
          config._cache_translate_unzip_path
        );
      })
      .then(() => {
        return this.uploadTranslations();
      });
  }
}

class Translate {
  constructor(source) {
    this._source = source;
    this._cache = null;
  }

  _getTranslates(lang) {
    if (lang) {
      if (!Array.isArray(lang)) {
        lang = [lang];
      }
    } else {
      lang = util.getLocalLangCodes();
    }
    let r = {};
    return lang
      .reduce((a, lang) => {
        return a.then(() => {
          return this._source._local.outputer
            .getTranslate(lang)
            .then((info) => {
              r[lang] = info;
            });
        });
      }, Promise.resolve())
      .then(() => r);
  }

  _getTranslate(lang, key) {
    if (!this._cache) {
      this._cache = new AsyncCache(() => {
        return this._getTranslates();
      });
    }
    return this._cache.get().then(({ result }) => {
      return result[lang][key];
    });
  }

  getTargetFiles() {
    return new File(config.buildSourcePath).getAllSubFilePaths();
  }

  outputTranslate(lang, files) {
    return files.reduce((b, path) => {
      return b.then(() => {
        if (config.gkeysSuffix.includes(Path.extname(path))) {
          return new File(path).read().then((content) => {
            return this._getTranslates(lang).then((translates) => {
              let ps = Promise.resolve(),
                info = {
                  lang,
                  translates,
                  content,
                  path,
                  regex: config.keyReg,
                  defaultLang: config.defaultLang,
                  sourcePath: config.sourcePath,
                };
              if (Hooker.has("translate-source-file")) {
                ps = ps.then(() => {
                  return Hooker.emit("translate-source-file", info).then(
                    ({ result }) => result
                  );
                });
              }
              ps = ps.then((_result) => {
                if (!_result) {
                  let result = content.replace(config.keyReg, (_, key) => {
                    return translates[lang][key] || key;
                  });
                  let f = path.substring(config.buildSourcePath.length);
                  if (f[0] === "/") {
                    f = `.${f}`;
                  } else {
                    f = `./${f}`;
                  }
                  let outputs = [];
                  if (config.defaultLang.lang === lang) {
                    outputs.push({
                      path: Path.resolve(config.buildOutputPath, f),
                      content: result,
                    });
                  }
                  outputs.push({
                    path: Path.resolve(config.buildOutputPath, `./${lang}`, f),
                    content: result,
                  });
                  return outputs;
                } else {
                  return _result;
                }
              });
              return ps.then((outputs) => {
                return outputs.reduce((a, { path, content }) => {
                  return a.then(() => {
                    return new File(path).write(content);
                  });
                }, Promise.resolve());
              });
            });
          });
        } else {
          let ps = Promise.resolve(),
            info = {
              lang,
              path,
              defaultLang: config.defaultLang,
              sourcePath: config.sourcePath,
            };
          if (Hooker.has("transport-source-transport")) {
            ps = ps.then(() => {
              return Hooker.emit("transport-source-transport", info).then(
                ({ result }) => result
              );
            });
          } else {
            ps = ps.then((result) => {
              if (!result) {
                let f = path.substring(config.buildSourcePath.length);
                if (f[0] === "/") {
                  f = `.${f}`;
                } else {
                  f = `./${f}`;
                }
                let outputPaths = [];
                if (config.defaultLang.lang === lang) {
                  outputPaths.push(Path.resolve(config.buildOutputPath, f));
                }
                outputPaths.push(
                  Path.resolve(config.buildOutputPath, `./${lang}`, f)
                );
                return outputPaths;
              } else {
                return _result;
              }
            });
          }
          return ps.then((outputPaths) => {
            return outputPaths.reduce((a, b) => {
              return a.then(() => {
                return new File(path).copyTo(b);
              });
            }, Promise.resolve());
          });
        }
      });
    }, Promise.resolve());
  }

  build() {
    let langs = util.getLocalLangCodes();
    return Hooker.emit("translate-source-start", {
      langs,
      total: langs.length,
      current: 0,
      progress: 0,
    })
      .then(() => {
        return this.getTargetFiles().then((paths) => {
          return langs.reduce((a, lang, index) => {
            return a
              .then(() => this.outputTranslate(lang, paths))
              .then(() => {
                return Hooker.emit("translate-source-progress", {
                  lang,
                  langs,
                  total: langs.length,
                  current: index + 1,
                  progress: parseInt(((index + 1) / langs.length) * 100),
                });
              });
          }, Promise.resolve());
        });
      })
      .then(() => {
        return Hooker.emit("translate-source-end", {});
      })
      .catch((e) => {
        return Hooker.emit("translate-source-end", { error: e });
      });
  }
}

class Local {
  constructor() {
    this._setHooker();
    this._project = config.project;
    this._localKeys = new Keys();
    this._outputer = new Outputter({
      keyFiles: this._localKeys,
    });
    this._branch = Cache(() => {
      return util.getBranchName().then((name) => {
        if (name) {
          return `${name}.json`;
        } else {
          return name;
        }
      });
    });
  }

  get outputer() {
    return this._outputer;
  }

  get keys() {
    return this._localKeys;
  }

  _setHooker() {
    Hooker._util = util;
    Hooker._remote = crowdin;
    Hooker._local = this;
  }

  _setProjectDetail(remote) {
    return new File(config._cache_project_path).write(JSON.stringify(remote));
  }

  getBranchName() {
    return this._branch.get().then(({ result }) => result);
  }

  getAllKeyInfosFromPath(path, suffixs = [".ejs", ".html"]) {
    let result = {};
    return new File(path).getAllSubFilePaths().then((files) => {
      files
        .filter((path) => Path.extname(path) === ".locale")
        .forEach((path) => {
          let info = JSON.parse(new SyncFile(path).read());
          if (Array.isArray(info)) {
            info.forEach((key) => {
              result[key] = path;
            });
          } else {
            Reflect.ownKeys(info).forEach((key) => {
              result[info[key]] = path;
            });
          }
        });
      return files
        .filter((path) => suffixs.indexOf(Path.extname(path)) !== -1)
        .reduce((a, path) => {
          return a.then(() => {
            let suffix = Path.extname(path);
            return new File(path).read().then((content) => {
              if (Hooker.has("get-keys-from")) {
                return Hooker.emit("get-keys-from", {
                  content,
                  path,
                  suffix,
                  keys: [],
                }).then(({ result, data }) => {
                  (result || data.keys).forEach((key) => (result[key] = path));
                });
              } else {
                content.replace(config.keyReg, (str) => {
                  let key = str.substring(2, str.length - 2);
                  result[key] = path;
                });
                content.replace(/{@(.*?)@}/g, (str) => {
                  let key = str.substring(2, str.length - 2);
                  result[key] = path;
                });
              }
            });
          });
        }, Promise.resolve())
        .then(() => result);
    });
  }

  getAllKeyInfosFromPaths(paths = [], suffixs = [".ejs", ".html"]) {
    let result = {};
    return paths
      .reduce((a, path) => {
        return a.then(() => {
          return this.getAllKeyInfosFromPath(path, suffixs).then((_result) => {
            Object.assign(result, _result);
          });
        });
      }, Promise.resolve())
      .then(() => {
        return result;
      });
  }

  getProjectDetail() {
    let r = null;
    if (!new File(config._cache_project_path).exist) {
      r = { files: [] };
    } else {
      try {
        r = require(config._cache_project_path) || { files: [] };
      } catch (e) {
        r = { files: [] };
      }
    }
    return this._localKeys.getList().then((files) => {
      r.files = r.files.filter(({ name, last_updated }) => {
        return (
          files.find(
            (a) =>
              a.name === name && a.time === new Date(last_updated).getTime()
          ) !== undefined
        );
      });
      return r;
    });
  }

  getKeys(option) {
    return this._localKeys.getKeys(option);
  }

  getOutputVariable() {
    return this._outputer.getOutputVariable();
  }

  removeKeyFile(fileName) {
    return this._localKeys.remove(fileName);
  }

  setKeyFile(fileName, content, time) {
    return this._localKeys.setContent(fileName, content, time);
  }

  recoverKeyFiles() {
    return this._localKeys.output(config.sourcePath);
  }

  output() {
    return util
      .unzip(config._cache_translate_path, config._cache_translate_unzip_path)
      .then(() => {
        return this._outputer.output(config.__cache_translate_unzip_path);
      })
      .catch(() => {
        return Hooker.emit("output-error-end", {}).then(() => {
          return new Promise((resolve, reject) => {
            return crowdin._v1
              .getDownloadStream()
              .on("response", () => {
                Hooker.emit("download-start");
              })
              .on("downloadProgress", (a) => {
                Hooker.emit("download-progress", a);
              })
              .pipe(fs.createWriteStream(config._cache_translate_path))
              .on("close", () => {
                Hooker.emit("download-end", {}).then(() => {
                  resolve();
                });
              })
              .on("error", (e) => {
                Hooker.emit("download-end", { error: e }).then(() => {
                  reject(e);
                });
              });
          })
            .then(() => {
              return Hooker.emit("output-start");
            })
            .then(() => {
              return this.output();
            });
        });
      });
  }

  reset() {
    return Promise.resolve()
      .then(() => {
        let t = new File(config._cache_project_path);
        if (t.exist) {
          return t.remove();
        }
      })
      .then(() => {
        let t = new File(config._cache_pro_path);
        if (t.exist) {
          return t.remove();
        }
      })
      .then(() => {
        let file = new File(config._cache_keys_path);
        if (file.exist) {
          return file.empty();
        }
      });
  }

  getPushedKeys() {
    return this.getBranchName().then((name) => {
      let file = new File(Path.resolve(config.sourcePath, name));
      if (file.exist) {
        return file.read().then((content) => {
          return JSON.parse(content);
        });
      } else {
        return Promise.resolve([]);
      }
    });
  }
}

class Finder {
  constructor(source) {
    this._source = source;
  }

  find(key) {
    return util
      .getGkeysFilePaths()
      .then((paths) => {
        let files = [];
        return paths
          .reduce((a, path) => {
            return a.then(() => {
              return new File(path).read().then((content) => {
                if (Hooker.has("get-keys-from")) {
                  return Hooker.emit("get-keys-from", {
                    content,
                    path,
                    suffix: Path.extname(path),
                    keys: [],
                  }).then(({ result, data }) => {
                    let keys = result || data.keys;
                    for (let i = 0; i < keys.length; i++) {
                      if (keys[i].indexOf(key) !== -1) {
                        files.push(path);
                        break;
                      }
                    }
                  });
                } else {
                  content.replace(config.keyReg, (_, str) => {
                    if (str.indexOf(key) !== -1) {
                      files.push(path);
                    }
                  });
                }
              });
            });
          }, Promise.resolve())
          .then(() => {
            return files;
          });
      })
      .then((files) => {
        let keys = [];
        return this._source._local._localKeys.getFileList().then((paths) => {
          return paths
            .reduce((a, path) => {
              return a.then(() => {
                return new File(path).read().then((content) => {
                  let f = JSON.parse(content);
                  let _keys = Reflect.ownKeys(f);
                  for (let i = 0; i < _keys.length; i++) {
                    let _key = _keys[i];
                    if (f[_key].indexOf(key) !== -1) {
                      keys.push(Path.basename(path));
                    }
                  }
                });
              });
            }, Promise.resolve())
            .then(() => {
              return {
                files: util.reduplicate(files),
                keys: util.reduplicate(keys),
              };
            });
        });
      });
  }
}

class Source {
  constructor() {
    this._local = new Local();
    this._robot = new Robot();
    this._isChanged = false;
  }

  get config() {
    return config;
  }

  get util() {
    return util;
  }

  get local() {
    return this._local;
  }

  get remote() {
    return crowdin;
  }

  get crowdin() {
    return crowdin;
  }

  _check() {
    return this.local.getBranchName().then((a) => {
      if (a !== undefined) {
        return Promise.resolve();
      } else {
        return Promise.reject(
          `You are in wrong branch,branch name pattern is ${config.gitBranchPattern.toString()}`
        );
      }
    });
  }

  _diff() {
    return Promise.resolve()
      .then(() => {
        return crowdin.getProjectDetail();
      })
      .then((remote) => {
        return this._local._setProjectDetail(remote).then(() => remote);
      })
      .then((remote) => {
        return this._local.getProjectDetail().then((local) => {
          return { remote, local };
        });
      })
      .then(({ remote, local }) => {
        let add = [],
          remove = [],
          edit = [];
        remote.files
          .filter((a) => a.node_type === "file")
          .forEach((_remote) => {
            let _local = local.files.find((a) => a.name === _remote.name);
            if (_local) {
              if (_local.last_updated !== _remote.last_updated) {
                edit.push(_local);
              }
            } else {
              add.push(_remote);
            }
          });
        if (local.files.length > remote.files.length) {
          local.files.forEach((_local) => {
            let _remote = remote.files.find((a) => a.name === _local.name);
            if (!_remote) {
              remove.push(_local);
            }
          });
        }
        local.files.forEach((a) => {
          let t = new File(Path.resolve(config._cache_keys_path, a.name));
          if (!t.exist) {
            if (!add.find((b) => b.name === a.name)) {
              add.push(a);
            }
          }
        });
        return { add, remove, edit, remote };
      });
  }

  diff() {
    return Hooker.emit("diff-start")
      .then((a) => {
        return this._diff();
      })
      .then((a) => {
        return Hooker.emit("diff-end", a).then(() => a);
      });
  }

  sync() {
    return Hooker.emit("sync-start")
      .then(() => {
        return this._diff();
      })
      .then((info) => {
        return Hooker.emit("sync-diff", { info }).then(
          ({ result, data }) => result || data.info
        );
      })
      .then(({ add, edit, remove, remote }) => {
        this._isChanged =
          add.length > 0 || edit.length > 0 || remove.length > 0;
        let ps = Promise.resolve(),
          total = add.length + edit.length + remove.length,
          done = 0;
        ps = ps.then(() => {
          return Hooker.emit("sync-progress", { total, done });
        });
        remove.forEach((file) => {
          ps = ps.then(() => {
            return Hooker.emit("sync-remove-start", { file })
              .then(() => {
                return this._local.removeKeyFile(file.name);
              })
              .then(() => {
                return Hooker.emit("sync-remove-end", { file });
              })
              .catch((e) => {
                return Hooker.emit("sync-remove-end", { file, error: e });
              })
              .then(() => {
                done++;
                return Hooker.emit("sync-progress", { total, done });
              });
          });
        });
        [...add].forEach((file) => {
          ps = ps.then(() => {
            return Hooker.emit("sync-add-start", { file })
              .then(() => {
                return crowdin.getFileContent(file.id, file.name);
              })
              .then((content) => {
                return this._local.setKeyFile(
                  file.name,
                  content,
                  file.last_updated
                );
              })
              .then(() => {
                return Hooker.emit("sync-add-end", { file });
              })
              .catch((e) => {
                return Hooker.emit("sync-add-end", { file, error: e });
              })
              .then(() => {
                done++;
                return Hooker.emit("sync-progress", { total, done });
              });
          });
        });
        [...edit].forEach((file) => {
          ps = ps.then(() => {
            return Hooker.emit("sync-edit-start", { file })
              .then(() => {
                return crowdin.getFileContent(file.id, file.name);
              })
              .then((content) => {
                return this._local.setKeyFile(file.name, content);
              })
              .then(() => {
                return Hooker.emit("sync-edit-end", { file });
              })
              .catch((e) => {
                return Hooker.emit("sync-edit-end", { file, error: e });
              })
              .then(() => {
                done++;
                return Hooker.emit("sync-progress", { total, done });
              });
          });
        });
        return ps.then(() => {
          return this._local.recoverKeyFiles();
        });
      })
      .then(() => {
        return Hooker.emit("sync-end", {});
      })
      .catch((e) => {
        return Hooker.emit("sync-end", { error: e });
      });
  }

  pull() {
    return Hooker.emit("pull-start")
      .then(() => {
        return this.sync();
      })
      .then(() => {
        return Hooker.emit("translate-get-start");
      })
      .then(() => {
        let isChanged = true;
        if (new File(config._cache_translate_path).exist) {
          isChanged = this._isChanged;
        }
        return crowdin.downloadLanguagePack(
          config._cache_translate_path,
          isChanged
        );
      })
      .then(() => {
        return Hooker.emit("translate-get-end", {});
      })
      .catch((e) => {
        return Hooker.emit("translate-get-end", { error: e });
      })
      .then(() => {
        return Hooker.emit("output-start");
      })
      .then(() => {
        return this._local.output();
      })
      .then(() => {
        return Hooker.emit("output-end", {});
      })
      .catch((e) => {
        return Hooker.emit("output-end", { error: e });
      })
      .then(() => {
        return Hooker.emit("pull-end", {});
      })
      .catch((e) => {
        return Hooker.emit("pull-end", { error: e });
      });
  }

  gkeys() {
    return Hooker.emit("gkeys-start")
      .then(() => {
        return this.sync();
      })
      .then(() => {
        return this._local.getBranchName();
      })
      .then((name) => {
        return this._local.getKeys({ departs: [name] });
      })
      .then((keys) => {
        return util
          .getGkeysPaths()
          .then((paths) => {
            return this._local.getAllKeyInfosFromPaths(
              paths,
              config.gkeysSuffix
            );
          })
          .then((a) => {
            return { keys, newKeys: a };
          });
      })
      .then(({ keys, newKeys }) => {
        let t = this._local.getOutputVariable();
        let keysInfo = {};
        Reflect.ownKeys(t).forEach((key) => {
          Object.assign(keysInfo, t[key]);
        });
        let departKeys = Reflect.ownKeys(keysInfo).filter(
          (key) => key !== "crowdin"
        );
        departKeys = departKeys.concat(keys);
        departKeys = departKeys.concat(config.departKeys || []);
        let result = {};
        Reflect.ownKeys(newKeys)
          .filter((key) => {
            return (
              departKeys.indexOf(key) === -1 && !config.langKeyPattern.test(key)
            );
          })
          .forEach((key) => {
            result[key] = newKeys[key];
          });
        return result;
      })
      .then((result) => {
        return Hooker.emit("gkeys-keys", { keys: result }).then(
          ({ result, data }) => {
            return result || data.keys;
          }
        );
      })
      .then((result) => {
        return Hooker.emit("gkeys-keys-result", { keys: result }).then(
          ({ result, data }) => {
            return result || data.keys;
          }
        );
      })
      .then((result) => {
        let n = new Set();
        Reflect.ownKeys(result).forEach((key) => {
          n.add(key);
        });
        return this._local.getBranchName().then((name) => {
          return { name, source: n };
        });
      })
      .then(({ name, source }) => {
        return new File(Path.resolve(config.sourcePath, `./${name}`))
          .write(JSON.stringify([...source], null, 4))
          .then(() => {
            return { name, keys: [...source] };
          });
      })
      .then(({ name, keys }) => {
        return Hooker.emit("gkeys-end", { name, keys });
      })
      .catch((e) => {
        return Hooker.emit("gkeys-end", { error: e });
      });
  }

  push({ comment }) {
    return Hooker.emit("push-start")
      .then(() => {
        return this._local.getBranchName();
      })
      .then((name) => {
        return Promise.resolve()
          .then(() => {
            return this.gkeys().then(() => {
              return new File(Path.resolve(config.sourcePath, `./${name}`));
            });
          })
          .then((file) => {
            return file.read();
          })
          .then((content) => {
            try {
              return JSON.parse(content);
            } catch (e) {
              return null;
            }
          })
          .then((info) => {
            return this._local.getKeys({ fileName: name }).then((a) => {
              return { cache: a, current: info };
            });
          })
          .then(({ cache, current }) => {
            let { add, remove } = util.diffArray(cache, current);
            return { add, remove, data: current };
          })
          .then((info) => {
            return Hooker.emit("push-keys", { info }).then(
              ({ result, data }) => result || data.info
            );
          })
          .then(({ add, remove, data }) => {
            if (add.length + remove.length > 0) {
              return crowdin
                .addOrUpdateFile({ fileName: name, data })
                .then(() => {
                  return { add, remove, name };
                });
            } else {
              return { add, remove, name };
            }
          });
      })
      .then(({ add, remove, name }) => {
        return Promise.resolve()
          .then(() => {
            if (config.dingdingRobot && add.length + remove.length > 0) {
              return this._robot.send({ add, remove, comment, name });
            }
          })
          .then(() => {
            return Hooker.emit("push-end", { add, remove, comment, name });
          });
      })
      .catch((e) => {
        return Hooker.emit("push-end", { error: e });
      });
  }

  reset() {
    this._local.reset();
  }

  status({ langCode, taskName }) {
    let info = { info: null, lang: langCode };
    if (langCode) {
      return Hooker.emit("status-start")
        .then(() => {
          return crowdin.getLanguageStatus(langCode);
        })
        .then((a) => {
          info.info = a;
          return Hooker.emit("status-end", info).then(
            ({ result, data }) => result || data.info
          );
        })
        .then((a) => {
          let b = a.files;
          if (taskName) {
            b = b.filter(
              (a) => a.name === `${config.filePrefix}_${taskName}.json`
            );
          }
          util.formatLanguageStatus(b);
        })
        .catch((e) => {
          return Hooker.emit("status-error", e);
        });
    } else {
      if (taskName) {
        let fileName = `${config.filePrefix}_${taskName}.json`;
        return Hooker.emit("status-start", info)
          .then(() => {
            return crowdin.getFileTranslateStatus(fileName).then((a) => a.data);
          })
          .then((a) => {
            info.info = a;
            return Hooker.emit("status-end", info).then(
              ({ result, data }) => result || data.info
            );
          })
          .then((a) => {
            util.formatFileTranslateStatus(a);
          })
          .catch((e) => {
            return Hooker.emit("status-error", e);
          });
      } else {
        return Hooker.emit("status-start", info)
          .then(() => {
            return crowdin.getTranslateStatus();
          })
          .then((a) => {
            info.info = a;
            return Hooker.emit("status-end", info).then(
              ({ result, data }) => result || data.info
            );
          })
          .then((a) => {
            util.formatTranslateStatus(a);
          })
          .catch((e) => {
            return Hooker.emit("status-error", e);
          });
      }
    }
  }

  translate() {
    return this.pull().then(() => {
      return new Translate(this).build();
    });
  }

  migrate({ project, key }) {
    if (project && key && project !== crowdin.projectName) {
      let t = new Migrate({ project, key, local: this.local });
      return t.check().then(() => {
        return t.invoke();
      });
    } else {
      return Promise.reject(
        "project or key cannot empty,or can not equal current"
      );
    }
  }

  find(key) {
    return Hooker.emit("find-start")
      .then(() => {
        return new Finder(this).find(key);
      })
      .then((a) => {
        return Hooker.emit("find-end").then(() => a);
      });
  }

  cat(taskName) {
    let file = `${config.filePrefix}_${taskName}.json`;
    if (this._local._localKeys.hasFile(file)) {
      return this._local._localKeys.getContentObject(file).then((a) => {
        return Reflect.ownKeys(a).map((b) => {
          return a[b];
        });
      });
    } else {
      return null;
    }
  }

  show() {
    return Hooker.emit("gkeys-start")
      .then(() => {
        return this.sync();
      })
      .then(() => {
        return this._local.getBranchName();
      })
      .then((name) => {
        return this._local.getKeys({ departs: [name] });
      })
      .then((keys) => {
        return util
          .getGkeysPaths()
          .then((paths) => {
            return this._local.getAllKeyInfosFromPaths(
              paths,
              config.gkeysSuffix
            );
          })
          .then((a) => {
            return { keys, newKeys: a };
          });
      })
      .then(({ keys, newKeys }) => {
        let t = this._local.getOutputVariable();
        let keysInfo = {};
        Reflect.ownKeys(t).forEach((key) => {
          Object.assign(keysInfo, t[key]);
        });
        let departKeys = Reflect.ownKeys(keysInfo).filter(
          (key) => key !== "crowdin"
        );
        departKeys = departKeys.concat(keys);
        departKeys = departKeys.concat(config.departKeys || []);
        let result = {};
        Reflect.ownKeys(newKeys)
          .filter((key) => {
            return (
              departKeys.indexOf(key) === -1 && !config.langKeyPattern.test(key)
            );
          })
          .forEach((key) => {
            result[key] = newKeys[key];
          });
        return result;
      })
      .then((result) => {
        return Hooker.emit("gkeys-keys", { keys: result }).then(
          ({ result, data }) => {
            return result || data.keys;
          }
        );
      })
      .then((result) => {
        return Hooker.emit("gkeys-keys-result", { keys: result }).then(
          ({ result, data }) => {
            return result || data.keys;
          }
        );
      })
      .then((result) => {
        return this._local.getBranchName().then((name) => {
          let n = new Set(),
            keys = Reflect.ownKeys(result);
          console.log(`Key File:${chalk(name).green}`);
          console.log(`Key Size:${chalk(keys.length).green}`);
          console.log("-----------------------");
          keys.forEach((key) => {
            n.add(key);
            console.log(`- ${chalk(key).green} ${chalk(result[key]).grey}`);
          });
          return { name, source: n };
        });
      })
      .then(({ name, keys }) => {
        return Hooker.emit("gkeys-end", { name, keys });
      })
      .catch((e) => {
        return Hooker.emit("gkeys-end", { error: e });
      });
  }
}

module.exports = Source;
