const fs = require("fs");
const excel = require("exceljs");
const crowdin = require("@crowdin/crowdin-api-client");

const TOKEN =
  "8e0e7e8c4de31297257d78f60c597dbc8bf183f2113f8108c82bdce89e6b3e45f93bcc993a94071d";
const apis = new crowdin.default({ token: TOKEN });
const months = Array.from({ length: 8 }).map((x, i) => `2022-0${i + 1}`);

apis.projectsGroupsApi
  .withFetchAll()
  .listProjects()
  .then((x) => {
    const projects = x.data.map((y) => y.data);

    const concurrency = 20;
    let projectChunks = [];
    while (projects.length > 0) {
      const chunks = projects.splice(0, concurrency);
      projectChunks.push(chunks);
    }
    console.log(`projects: ${projectChunks.length}`);

    return projectChunks.reduce((p, cur, i) => {
      const getProjectStrings = (c) => {
        return apis.sourceStringsApi
          .withFetchAll()
          .listProjectStrings(c.id)
          .then((s) => {
            const current = {
              project: c.id,
              name: c.name,
              strings: s.data.length,
              allStrings: s.data.map((y) => y.data.text),
              langs: c.targetLanguageIds.length,
              createdAt: c.createdAt,
              updatedAt: c.updatedAt,
              lastActivity: c.lastActivity,
            };
            // group strings by month
            months.forEach(
              (m) =>
                (current[m] = s.data.filter((x) =>
                  x.data.createdAt.startsWith(m)
                ).length)
            );
            // get file count
            const fileIdGroups = groupBy(
              s.data.map((x) => x.data),
              (item) => item.fileId
            );
            current.files = Object.keys(fileIdGroups).length;
            console.log(
              `  project: ${current.name}, strings: ${current.strings}, langs: ${current.langs}`
            );
            return current;
          })
          .catch(
            (e) => (
              console.log(e),
              {
                project: c.id,
                name: c.name,
                strings: 0,
                langs: 0,
              }
            )
          );
      };

      const getStrings = (
        chunks,
        { allStrings, totalProjects, totalStrings, list }
      ) => {
        return Promise.all(
          chunks.map((chunk) => getProjectStrings(chunk))
        ).then((chunkResults) => {
          const totalP = totalProjects + chunkResults.length;
          const totalS =
            totalStrings + chunkResults.reduce((x, y) => x + y.strings, 0);
          const allS = chunkResults.forEach(
            (x) =>
              x.allStrings && x.allStrings.forEach((y) => (allStrings[y] = 1))
          );
          console.log(
            `totalProjects:${totalP}, totalStrings:${totalS},allStrings:${
              Object.keys(allStrings).length
            }`
          );
          return {
            allStrings,
            totalProjects: totalP,
            totalStrings: totalS,
            list: [...list, ...chunkResults],
          };
        });
      };

      return p.then((params) => {
        return getStrings(cur, params);
      });
    }, Promise.resolve({ allStrings: {}, totalProjects: 0, totalStrings: 0, list: [] }));
  })
  .then((x) => {
    fs.writeFileSync("usage.json", JSON.stringify(x));
    return toExcel(
      "usage.xlsx",
      "",
      x.list.map((y) => Object.values(y)),
      { startRowIndex: 2 }
    );
  });

function toExcel(filePath, sheetName, contents, options) {
  const book = new excel.Workbook().xlsx;
  book
    .readFile(filePath)
    .then((x) => {
      let worksheet = x.worksheets.find(
        (x) => x.name === (sheetName || "Sheet1")
      );
      if (!worksheet) worksheet = x.addWorksheet(sheetName);
      const startRowIndex = options.startRowIndex || worksheet.rowCount + 1;
      contents.forEach((item, index) =>
        worksheet.insertRow(startRowIndex + index, item)
      );
      return x;
    })
    .then((x) => {
      return x.xlsx.writeFile(filePath);
    });
}

function groupBy(collection, iteratee) {
  const init = {};
  return collection.reduce((result, item, index) => {
    const key = iteratee(item, index);
    const hasKey = Object.hasOwnProperty.call(result, key);
    hasKey ? result[key].push(item) : (result[key] = [item]);
    return result;
  }, init);
}
