const program = require('commander');
const crowdin = require('../src/index');
const package = require('../package.json');
const chalk = require('chalk');
const config = require('./../src/config/index');
const { File } = require('ada-util');
const Path = require('path');
const Open = require('open');
const Package = require('./../package.json');

program
    .version(package.version, '-v, --version')
    .description(chalk(`[ ${package.description} - ${package.version.toUpperCase()} ]`).green);
program
    .command('pull')
    .option('-l,--log [log]', 'show log detail')
    .description('sync and download translates')
    .action((option) => {
        let { log } = option;
        if (log) {
            config._showLog = true;
        }
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t._check().then(() => {
                t.pull();
            }).catch(e => {
                console.log(e);
            });
        }
    });
program
    .command('push')
    .option('-c,--comment <comment>', 'comment send to dingding group')
    .option('-l,--log [log]', 'show log detail')
    .description('gkeys and push keys to remote')
    .action((option) => {
        let { comment, log } = option;
        if (log) {
            config._showLog = true;
        }
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t._check().then(() => {
                t.push({ comment });
            }).catch(e => {
                console.log(e);
            });
        }
    });
program
    .command('status')
    .alias('st')
    .option('-l,--lang-code [item]', 'local lang code like "en-us"')
    .option('-t,--task-name [name]', 'task name')
    .description('show translate status')
    .action((option) => {
        let { langCode, taskName } = option;
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t.status({ langCode, taskName });
        }
    });
program
    .command('find')
    .alias('fd')
    .description('find which file contains the key')
    .option('-k,--key-name [key]', 'key name')
    .action((option) => {
        let { keyName } = option;
        let t = new crowdin();
        if (t.util.healthCheck()) {
            if (!keyName) {
                console.log('key name can not empty');
            } else {
                t.find(keyName).then(({ files, keys }) => {
                    if (files.length > 0) {
                        console.log(chalk('- the key appears in the following files').green);
                        console.log('  --------------------------------------');
                        console.log(chalk('  Source Files:').green);
                        files.forEach(file => {
                            console.log(`   ${file}`);
                        });
                    }
                    if (keys.length > 0) {
                        console.log(chalk('  Key Files:').green);
                        keys.forEach(file => {
                            console.log(`   ${file}`);
                        });
                    }
                });
            }
        }
    });
program
    .command('diff')
    .alias('df')
    .description('view differents between remote')
    .action(() => {
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t.diff().then(({ add, remove, edit }) => {
                if (add.length > 0) {
                    console.log(chalk('Add:').green);
                    add.forEach(a => {
                        console.log(` - ${a.name}`);
                    });
                } else {
                    console.log(chalk('Add:').green, 'nothing');
                }
                if (remove.length > 0) {
                    console.log(chalk('Remove:').green);
                    remove.forEach(a => {
                        console.log(` - ${a.name}`);
                    });
                } else {
                    console.log(chalk('Remove:').green, 'nothing');
                }
                if (edit.length > 0) {
                    console.log(chalk('Edit:').green);
                    edit.forEach(a => {
                        console.log(` - ${a.name}`);
                    });
                } else {
                    console.log(chalk('Edit:').green, 'nothing');
                }
            });
        }
    });
program
    .command('cat')
    .option('-n,--key-file-name [name]', 'key file name(task name)')
    .option('-l,--log [log]', 'show log detail')
    .description('view key file content')
    .action((option) => {
        let { keyFileName } = option;
        if (keyFileName) {
            let t = new crowdin();
            if (t.util.healthCheck()) {
                t.cat(keyFileName).then(a => {
                    if (a) {
                        a.forEach(b => {
                            console.log(`- ${chalk(b).green}`);
                        });
                    } else {
                        console.log('no file to display');
                    }
                });
            }
        } else {
            console.log('key file name can not empty');
        }
    });
program
    .command('show')
    .alias('sh')
    .description('show keys of current task')
    .action(() => {
        new crowdin().show();
    });
program
    .command('sync')
    .description('sync local to remote')
    .action(() => {
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t.sync();
        }
    });
program
    .command('reset')
    .description('reset local state')
    .action(() => {
        new crowdin().reset();
    });
program
    .command('gkeys')
    .alias('gk')
    .option('-l,--log [log]', 'show log detail')
    .description(`${chalk('[deprecated]'.red)} generate keys from files`)
    .action((option) => {
        let { log } = option;
        if (log) {
            config._showLog = true;
        }
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t._check().then(() => {
                t.gkeys();
            }).catch(e => {
                console.log(e);
            });
        }
    });
program
    .command('translate')
    .alias('ts')
    .option('-l,--log [log]', 'show log detail')
    .description(`${chalk('[experiment]'.green)} translate source`)
    .action((option) => {
        let { langCode, taskName } = option;
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t.translate({ langCode, taskName });
        }
    });
program
    .command('migrate')
    .alias('mig')
    .option('-n,--project-name <name>', 'target project name')
    .option('-k,--project-key <token>', 'target project key')
    .option('-l,--log [log]', 'show log detail')
    .description(`${chalk('[experiment]'.green)} merge and migrate form current to anohter`)
    .action((option) => {
        let { projectName, projectKey, log } = option;
        if (log) {
            config._showLog = true;
        }
        let t = new crowdin();
        if (t.util.healthCheck()) {
            t.local.getBranchName().then(a => {
                if (a === 'master.json') {
                    return t.migrate({ project: projectName, key: projectKey }).catch(e => {
                        console.log(e);
                    });
                } else {
                    console.log('current branch must master :)');
                }
            });
        }
    });
program
    .command('init')
    .description('initalize fed-crowdin config file')
    .action(() => {
        let path = Path.resolve(process.cwd(), './crowdin.hb.js');
        if (new File(path).exist) {
            console.log(chalk(`file crowdin.hb.js is exist`).yellow);
        } else {
            let tpl = Path.resolve(__dirname, './../src/config/config.tpl');
            return new File(tpl).read().then(content => {
                return new File(path).write(content);
            }).then(() => {
                console.log(chalk(`file crowdin.hb.js is created,path is ${path}`).green);
            });
        }
    });
program
    .command('doc')
    .description(`read documents of fed-crowdin`)
    .action(() => {
        Open(Package.doc);
    });

config.commands.filter(a => !!a.name).forEach(({ name, alias, options, description, action }) => {
    let t = program.command(name);
    if (!description) {
        description = 'this custom command has not desc';
    }
    if (description) {
        description = `${chalk('[custom]').blue} ${description}`;
        t = t.description(description);
    }
    if (alias) {
        t = t.alias(alias);
    }
    (options || []).forEach(({ param, desc }) => {
        t = t.option(param, desc);
    });
    t.action(option => {
        let t = new crowdin();
        if (t.util.healthCheck()) {
            action(t, option);
        }
    });
});

program.parse(process.argv);